<!DOCTYPE html><html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Knight Move Puzzle</title>
  <style>
    :root {
      --bg-light: linear-gradient(120deg, #f8f9fa, #e0f7fa);
      --bg-dark: linear-gradient(120deg, #1e1e1e, #2b2b2b);
      --text-light: #0d47a1;
      --text-dark: #ffffff;
    }
    body {
      font-family: 'Segoe UI', sans-serif;
      text-align: center;
      margin-top: 30px;
      background: var(--bg-light);
      color: var(--text-light);
      transition: all 0.3s ease-in-out;
    }
    body.dark-mode {
      background: var(--bg-dark);
      color: var(--text-dark);
    }
    table {
      margin: auto;
      border-collapse: separate;
      border-spacing: 5px;
      box-shadow: 0 0 20px rgba(0,0,0,0.2);
    }
    td {
      width: 60px;
      height: 60px;
      background: linear-gradient(145deg, #f0f0f0, #cacaca);
      border-radius: 10px;
      font-size: 22px;
      font-weight: bold;
      text-align: center;
      vertical-align: middle;
      cursor: pointer;
      box-shadow: 5px 5px 10px #bebebe, -5px -5px 10px #ffffff;
      transition: all 0.2s ease-in-out;
    }
    td:hover {
      transform: scale(1.05);
    }
    td.valid {
      background-color: #a5d6a7;
      color: #1b5e20;
    }
    td.filled {
      background-color: #4fc3f7;
      color: white;
      animation: pop 0.3s ease-in-out;
    }
    td.hint {
      background-color: #fff176;
    }
    td.path {
      outline: 2px dashed orange;
    }
    @keyframes pop {
      0% { transform: scale(0.8); opacity: 0.5; }
      100% { transform: scale(1); opacity: 1; }
    }
    button, select, input[type="color"] {
      margin: 10px;
      padding: 10px 14px;
      font-size: 16px;
      border: none;
      border-radius: 8px;
      background: linear-gradient(to right, #42a5f5, #478ed1);
      color: white;
      cursor: pointer;
      box-shadow: 3px 3px 8px rgba(0,0,0,0.2);
      transition: background 0.3s ease-in-out;
    }
    button:hover {
      background: linear-gradient(to right, #1976d2, #0d47a1);
    }
    #status {
      font-weight: bold;
      font-size: 24px;
    }
    #gameOver {
      font-size: 48px;
      color: red;
      font-weight: bold;
      margin-top: 20px;
      display: none;
    }
    progress {
      width: 60%;
      height: 20px;
    }
  </style>
</head>
<body>
  <h1>Knight Move Puzzle</h1>
  <div>
    <button onclick="undoMove()">Undo</button>
    <button onclick="resetGame()">Reset</button>
    <button onclick="showHints()">Show Hints</button>
    <button onclick="toggleTheme()">Toggle Dark/Light Mode</button>
    <button onclick="togglePause()">Pause</button>
    <label>Font Color: <input type="color" id="fontColorPicker" onchange="updateFontColor()"></label>
    <label>Font Type:
      <select id="fontTypeSelector" onchange="updateFontType()">
        <option value="Segoe UI">Segoe UI</option>
        <option value="Courier New">Courier New</option>
        <option value="Comic Sans MS">Comic Sans MS</option>
        <option value="Arial">Arial</option>
        <option value="Georgia">Georgia</option>
      </select>
    </label>
    <label>Mode:
      <select id="modeSelector" onchange="changeMode()">
        <option value="6">Classic (6x6)</option>
        <option value="5">Easy (5x5)</option>
        <option value="8">Hard (8x8)</option>
      </select>
    </label>
  </div>
  <table id="grid"></table>
  <progress id="progressBar" value="0" max="36"></progress>
  <p id="status">Click any cell to start with 1.</p>
  <p>Moves: <span id="moveCount">0</span> | Time: <span id="timer">0</span>s | Score: <span id="score">0</span></p>
  <div id="gameOver">GAME OVER</div>  <script>
    let gridSize = 6;
    let currentNumber = 1;
    let lastRow = null, lastCol = null;
    let moveHistory = [];
    let timer = 0, timerInterval;
    let isPaused = false;

    const grid = document.getElementById('grid');
    const status = document.getElementById('status');
    const moveCountEl = document.getElementById('moveCount');
    const timerEl = document.getElementById('timer');
    const scoreEl = document.getElementById('score');
    const fontColorPicker = document.getElementById('fontColorPicker');
    const fontTypeSelector = document.getElementById('fontTypeSelector');
    const gameOverEl = document.getElementById('gameOver');
    const progressBar = document.getElementById('progressBar');
    const modeSelector = document.getElementById('modeSelector');

    function toggleTheme() {
      document.body.classList.toggle("dark-mode");
    }

    function togglePause() {
      isPaused = !isPaused;
      if (isPaused) clearInterval(timerInterval);
      else startTimer();
    }

    function changeMode() {
      gridSize = parseInt(modeSelector.value);
      resetGame();
      grid.innerHTML = '';
      createGrid();
    }

    function createGrid() {
      for (let r = 0; r < gridSize; r++) {
        const row = grid.insertRow();
        for (let c = 0; c < gridSize; c++) {
          const cell = row.insertCell();
          cell.dataset.row = r;
          cell.dataset.col = c;
          cell.addEventListener('click', handleClick);
        }
      }
    }

    function handleClick(e) {
      if (isPaused) return;
      const cell = e.target;
      const row = parseInt(cell.dataset.row);
      const col = parseInt(cell.dataset.col);
      if (cell.textContent !== '') return;
      if (currentNumber === 1 || isKnightMove(row, col)) {
        if (moveHistory.length > 0) {
          const prev = moveHistory[moveHistory.length - 1];
          grid.rows[prev.row].cells[prev.col].classList.remove('path');
        }
        cell.textContent = currentNumber;
        cell.classList.add('filled', 'path');
        cell.style.color = fontColorPicker.value;
        cell.style.fontFamily = fontTypeSelector.value;
        moveHistory.push({ row, col, number: currentNumber });
        lastRow = row;
        lastCol = col;
        currentNumber++;
        moveCountEl.textContent = moveHistory.length;
        progressBar.max = gridSize * gridSize;
        progressBar.value = currentNumber - 1;
        highlightValidMoves();
        startTimer();
        calculateScore();
        saveGameState();
        if (currentNumber > gridSize * gridSize) {
          clearInterval(timerInterval);
          calculateScore();
          status.textContent = "\u2728 Congratulations! Puzzle complete in " + timer + "s \u2728";
          saveScore(scoreEl.textContent);
        } else if (!hasAnyValidMoves()) {
          clearInterval(timerInterval);
          calculateScore();
          gameOverEl.style.display = 'block';
          status.textContent = "No more moves available.";
        } else {
          status.textContent = `Now place ${currentNumber}`;
        }
      }
    }

    function isKnightMove(r, c) {
      if (lastRow === null || lastCol === null) return true;
      const dr = Math.abs(r - lastRow);
      const dc = Math.abs(c - lastCol);
      return (dr === 2 && dc === 1) || (dr === 1 && dc === 2);
    }

    function highlightValidMoves() {
      for (let row of grid.rows) {
        for (let cell of row.cells) {
          const r = parseInt(cell.dataset.row);
          const c = parseInt(cell.dataset.col);
          if (cell.textContent === '') {
            if (isKnightMove(r, c)) {
              cell.classList.add('valid');
              cell.style.backgroundColor = '#a5d6a7';
            } else {
              cell.classList.remove('valid');
              cell.style.backgroundColor = '';
            }
          } else {
            cell.classList.remove('valid');
            cell.style.backgroundColor = '';
          }
        }
      }
    }

    function hasAnyValidMoves() {
      for (let r = 0; r < gridSize; r++) {
        for (let c = 0; c < gridSize; c++) {
          if (grid.rows[r].cells[c].textContent === '' && isKnightMove(r, c)) {
            return true;
          }
        }
      }
      return false;
    }

    function startTimer() {
      if (!timerInterval) {
        timerInterval = setInterval(() => {
          timer++;
          timerEl.textContent = timer;
        }, 1000);
      }
    }

    function calculateScore() {
      const progressFactor = (currentNumber - 1) / (gridSize * gridSize);
      const speedFactor = timer > 0 ? (1 / timer) : 0;
      const score = Math.round(progressFactor * 800 + speedFactor * 200 * progressFactor);
      scoreEl.textContent = score;
    }

    function resetGame() {
      clearInterval(timerInterval);
      timer = 0;
      timerInterval = null;
      timerEl.textContent = '0';
      scoreEl.textContent = '0';
      currentNumber = 1;
      lastRow = lastCol = null;
      moveHistory = [];
      status.textContent = "Click any cell to start with 1.";
      moveCountEl.textContent = '0';
      gameOverEl.style.display = 'none';
      grid.innerHTML = '';
      createGrid();
      progressBar.value = 0;
    }

    function undoMove() {
      if (moveHistory.length === 0) return;
      const lastMove = moveHistory.pop();
      const cell = grid.rows[lastMove.row].cells[lastMove.col];
      cell.textContent = '';
      cell.classList.remove('filled', 'path');
      cell.style.color = '';
      cell.style.fontFamily = '';
      currentNumber--;
      moveCountEl.textContent = moveHistory.length;
      progressBar.value = currentNumber - 1;
      if (moveHistory.length > 0) {
        const prev = moveHistory[moveHistory.length - 1];
        lastRow = prev.row;
        lastCol = prev.col;
      } else {
        lastRow = lastCol = null;
      }
      status.textContent = `Now place ${currentNumber}`;
      highlightValidMoves();
      calculateScore();
      gameOverEl.style.display = 'none';
      startTimer();
    }

    function showHints() {
      for (let row of grid.rows) {
        for (let cell of row.cells) {
          cell.classList.remove('hint');
          const r = parseInt(cell.dataset.row);
          const c = parseInt(cell.dataset.col);
          if (cell.textContent === '' && isKnightMove(r, c)) {
            const moves = countNextKnightMoves(r, c);
            if (moves <= 2) {
              cell.classList.add('hint');
            }
          }
        }
      }
    }

    function countNextKnightMoves(r, c) {
      const knightMoves = [
        [2, 1], [1, 2], [-1, 2], [-2, 1],
        [-2, -1], [-1, -2], [1, -2], [2, -1]
      ];
      let count = 0;
      for (let [dr, dc] of knightMoves) {
        let nr = r + dr;
        let nc = c + dc;
        if (nr >= 0 && nr < gridSize && nc >= 0 && nc < gridSize) {
          let nextCell = grid.rows[nr].cells[nc];
          if (nextCell.textContent === '') count++;
        }
      }
      return count;
    }

    function updateFontColor() {
      for (let row of grid.rows) {
        for (let cell of row.cells) {
          if (cell.classList.contains('filled')) {
            cell.style.color = fontColorPicker.value;
          }
        }
      }
    }

    function updateFontType() {
      for (let row of grid.rows) {
        for (let cell of row.cells) {
          if (cell.classList.contains('filled')) {
            cell.style.fontFamily = fontTypeSelector.value;
          }
        }
      }
    }

    function saveGameState() {
      const state = {
        gridSize,
        currentNumber,
        lastRow,
        lastCol,
        moveHistory,
        timer
      };
      localStorage.setItem('gameState', JSON.stringify(state));
    }

    function loadGameState() {
      const state = JSON.parse(localStorage.getItem('gameState'));
      if (!state) return;
      gridSize = state.gridSize;
      modeSelector.value = gridSize;
      resetGame();
      for (let move of state.moveHistory) {
        const cell = grid.rows[move.row].cells[move.col];
        cell.textContent = move.number;
        cell.classList.add('filled');
        moveHistory.push(move);
        lastRow = move.row;
        lastCol = move.col;
        currentNumber = move.number + 1;
      }
      timer = state.timer;
      timerEl.textContent = timer;
      moveCountEl.textContent = moveHistory.length;
      progressBar.max = gridSize * gridSize;
      progressBar.value = currentNumber - 1;
      highlightValidMoves();
      calculateScore();
      startTimer();
    }

    function saveScore(score) {
      let scores = JSON.parse(localStorage.getItem('scores') || '[]');
      scores.push({ score: parseInt(score), time: timer });
      scores.sort((a, b) => b.score - a.score);
      scores = scores.slice(0, 5);
      localStorage.setItem('scores', JSON.stringify(scores));
    }

    window.addEventListener('DOMContentLoaded', () => {
      createGrid();
      loadGameState();
    });
  </script></body>
</html>
